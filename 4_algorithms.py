def quicksort(arr):
    '''
    Алгоритм быстрой сортировки:
    1. Выберите опорный элемент (например, последний элемент массива).
    2. Разделите массив на две части: элементы меньше опорного и элементы больше опорного.
    3. Рекурсивно примените быструю сортировку к обеим частям.
    4. Объедините отсортированные подмассивы.

    arr (List[int]): Массив чисел для сортировки.
    '''
    if len(arr) <= 1:  # Базовый случай: массив уже отсортирован
        return arr
    else:
        pivot = arr[-1]  # Опорный элемент (последний элемент массива)
        left = [x for x in arr[:-1] if x <= pivot]  # Элементы меньше или равные опорному
        right = [x for x in arr[:-1] if x > pivot]  # Элементы больше опорного

        return quicksort(left) + [pivot] + quicksort(right)  # Рекурсивно сортируем и объединяем
    
# Пример использования
# array = [10, 7, 8, 9, 1, 5]
# sorted_array = quicksort(array)
# print("Отсортированный массив:", sorted_array)


def binary_search(arr, target, sorted=True):
    '''
    Алгоритм бинарного поиска:
    1. Установите два указателя: low (нижняя граница) на начало массива и high (верхняя граница) на конец массива.
    Пока low меньше или равно high:
    2. Найдите средний индекс mid как (low + high) // 2.
    Если элемент по индексу mid равен искомому значению, верните индекс mid.
    Если элемент по индексу mid меньше искомого значения, установите low на mid + 1.
    Если элемент по индексу mid больше искомого значения, установите high на mid - 1.
    Если элемент не найден, верните значение, указывающее на отсутствие элемента (например, -1).

    arr (List[int]): Массив чисел для поиска.
    target (int): Искомое значение.
    sorted (bool): Флаг, указывающий, отсортирован ли массив (по умолчанию True).
    '''
    low = 0
    high = len(arr) - 1

    if not sorted:
        arr = quicksort(arr)

    while low <= high:
        mid = (low + high) // 2  # Находим средний индекс

        if arr[mid] == target:
            return mid  # Элемент найден, возвращаем его индекс
        elif arr[mid] < target:
            low = mid + 1  # Ищем в правой половине
        else:
            high = mid - 1  # Ищем в левой половине

    return -1  # Элемент не найден

# Пример использования
#sorted_array = [1, 3, 5, 7, 9, 11, 13]
unsorted_array = [10, 7, 8, 9, 1, 5]
target_value = 1

result = binary_search(unsorted_array, target_value, sorted=False)
if result != -1:
    print(f"Элемент {target_value} найден на индексе {result}.")
else:
    print(f"Элемент {target_value} не найден.")
